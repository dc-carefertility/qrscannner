<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mic detector → Power Automate GET</title>
<style>
  :root { --warn:#b71c1c; }
  body { font-family: system-ui, Arial, sans-serif; max-width: 720px; margin: 2rem auto; padding: 0 1rem; }
  fieldset { margin: 1rem 0; }
  label { display:block; margin:.5rem 0 .25rem; }
  input[type="text"], input[type="number"] { width: 100%; padding:.5rem; }
  .row { display:flex; gap:1rem; flex-wrap:wrap; }
  .row > div { flex:1 1 200px; }
  .status { margin-top:.5rem; font-size:.9rem; opacity:.85; }
  button { padding:.6rem 1rem; }
  meter { width:100%; height:1rem; }
  .alert { display:none; margin:1rem 0; padding:.75rem 1rem; background:#ffebee; color:var(--warn); border:1px solid var(--warn); border-radius:8px; font-weight:600; animation:pulse 1.2s infinite; }
  .alert.on { display:block; }
  @keyframes pulse { 0%{box-shadow:0 0 0 0 rgba(183,28,28,.35)} 70%{box-shadow:0 0 0 14px rgba(183,28,28,0)} 100%{box-shadow:0 0 0 0 rgba(183,28,28,0)} }
</style>
<body>
  <h1>Mic detector → Power Automate (GET on hold)</h1>

  <fieldset>
    <legend>Settings</legend>
    <label>Power Automate HTTP trigger URL</label>
    <input id="apiUrl" type="text" placeholder="paste your Flow URL">
    <div class="row">
      <div>
        <label>RMS threshold</label>
        <input id="threshold" type="number" step="0.005" min="0.005" value="0.02">
      </div>
      <div>
        <label>Hold seconds</label>
        <input id="holdSecs" type="number" min="0.2" step="0.1" value="2">
      </div>
      <div>
        <label>Cooldown seconds</label>
        <input id="cooldown" type="number" min="0" value="30">
      </div>
    </div>
  </fieldset>

  <div class="row">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="wakeBtn" title="Keep screen awake">Screen wake lock</button>
  </div>

  <div id="alert" class="alert">Threshold held for over <span id="holdTarget">2</span> seconds. Alert sent.</div>

  <fieldset>
    <legend>Live</legend>
    <label>Current RMS</label>
    <meter id="meter" min="0" max="0.2" value="0"></meter>

    <label style="margin-top:.75rem;">Hold progress</label>
    <meter id="holdMeter" min="0" max="2" value="0"></meter>

    <div class="status" id="status">Idle</div>
    <div class="status" id="lastSent">Last sent: never</div>
    <div class="status" id="holdInfo">Held above threshold: 0.00s</div>
  </fieldset>

<script>
let ac, mic, analyser, rafId, wakeLock;
let lastTime = 0, holdMs = 0;
let sentForCurrentHold = false;
let lastSentAt = 0;

const els = {
  meter: document.getElementById('meter'),
  holdMeter: document.getElementById('holdMeter'),
  status: document.getElementById('status'),
  lastSent: document.getElementById('lastSent'),
  holdInfo: document.getElementById('holdInfo'),
  alert: document.getElementById('alert'),
  holdTarget: document.getElementById('holdTarget'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  wakeBtn: document.getElementById('wakeBtn'),
  apiUrl: document.getElementById('apiUrl'),
  threshold: document.getElementById('threshold'),
  holdSecs: document.getElementById('holdSecs'),
  cooldown: document.getElementById('cooldown')
};

async function start() {
  try {
    if (!location.protocol.startsWith('https') && location.hostname !== 'localhost') {
      alert('Mic access usually requires HTTPS. Serve this over HTTPS.');
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });
    ac = new (window.AudioContext || window.webkitAudioContext)();
    mic = ac.createMediaStreamSource(stream);
    analyser = ac.createAnalyser();
    analyser.fftSize = 2048;
    mic.connect(analyser);

    holdMs = 0;
    sentForCurrentHold = false;
    lastTime = performance.now();
    els.holdTarget.textContent = String(parseFloat(els.holdSecs.value || '2'));

    loop();
    els.startBtn.disabled = true;
    els.stopBtn.disabled = false;
    setStatus('Listening');
  } catch (e) {
    console.error(e);
    setStatus('Mic permission denied or unavailable');
  }
}

function stop() {
  cancelAnimationFrame(rafId);
  if (ac) ac.close();
  ac = mic = analyser = null;
  els.startBtn.disabled = false;
  els.stopBtn.disabled = true;
  setStatus('Stopped');
  setAlert(false);
}

function setStatus(t) { els.status.textContent = t; }
function setAlert(on) { els.alert.classList.toggle('on', on); }

function rmsFromTimeDomain(buf) {
  let sum = 0;
  for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
  return Math.sqrt(sum / buf.length);
}

// Fire a GET to the Flow URL using an image beacon to avoid CORS
function sendGet(rms, reason) {
  const base = els.apiUrl.value.trim();
  if (!base) return;
  const qs = new URLSearchParams({
    event: reason || 'sound_hold_reached',
    rms: rms.toFixed(4),
    ts: Math.floor(Date.now() / 1000).toString(),
    source: 'web-mic'
  });
  const img = new Image();
  img.src = `${base}&${qs.toString()}`;
  // Keep a reference briefly so it is not GC'd before the request goes
  setTimeout(() => { /* allow GC */ }, 3000);
  lastSentAt = Date.now();
  els.lastSent.textContent = `Last sent: ${new Date(lastSentAt).toLocaleString()}`;
}

function loop() {
  const thresh = parseFloat(els.threshold.value || '0.02');
  const holdSecs = Math.max(0.2, parseFloat(els.holdSecs.value || '2'));
  const cooldownMs = Math.max(0, parseInt(els.cooldown.value || '30', 10) * 1000);

  els.holdMeter.max = holdSecs;
  els.holdTarget.textContent = String(holdSecs);

  const now = performance.now();
  const dt = now - lastTime;
  lastTime = now;

  const buf = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buf);
  const rms = rmsFromTimeDomain(buf);
  els.meter.value = Math.min(0.2, rms);

  const over = rms >= thresh;

  if (over) {
    holdMs += dt;
    // When the hold threshold is crossed for the first time, and cooldown has passed, fire once
    if (!sentForCurrentHold && holdMs >= holdSecs * 1000 && Date.now() - lastSentAt >= cooldownMs) {
      setAlert(true);
      setStatus(`Hold reached. rms=${rms.toFixed(4)}. Sending GET`);
      sendGet(rms, 'sound_hold_reached');
      sentForCurrentHold = true;
    }
  } else {
    holdMs = 0;
    if (sentForCurrentHold) {
      // Re-arm once levels drop back below threshold
      sentForCurrentHold = false;
      setAlert(false);
    }
  }

  els.holdMeter.value = holdMs / 1000;
  els.holdInfo.textContent = `Held above threshold: ${(holdMs/1000).toFixed(2)}s`;

  if (!sentForCurrentHold) {
    setStatus(`Listening, rms=${rms.toFixed(4)}`);
  }

  rafId = requestAnimationFrame(loop);
}

// Screen wake lock to reduce throttling
async function toggleWake() {
  if ('wakeLock' in navigator) {
    try {
      if (!wakeLock) {
        wakeLock = await navigator.wakeLock.request('screen');
        els.wakeBtn.textContent = 'Release wake lock';
        wakeLock.addEventListener('release', () => els.wakeBtn.textContent = 'Screen wake lock');
      } else {
        await wakeLock.release();
        wakeLock = null;
        els.wakeBtn.textContent = 'Screen wake lock';
      }
    } catch (e) {
      alert('Wake lock not available');
    }
  } else {
    alert('Wake lock API not supported on this browser');
  }
}

els.startBtn.addEventListener('click', start);
els.stopBtn.addEventListener('click', stop);
els.wakeBtn.addEventListener('click', toggleWake);
</script>
</body>
</html>
