<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mic sound detector to API</title>
<style>
  :root { --ok:#1b5e20; --warn:#b71c1c; }
  body { font-family: system-ui, Arial, sans-serif; max-width: 720px; margin: 2rem auto; padding: 0 1rem; }
  fieldset { margin: 1rem 0; }
  label { display:block; margin:.5rem 0 .25rem; }
  input[type="text"], input[type="number"] { width: 100%; padding:.5rem; }
  .row { display:flex; gap:1rem; }
  .row > div { flex:1; }
  .status { margin-top: .5rem; font-size: .9rem; opacity: .85; }
  button { padding:.6rem 1rem; }
  meter { width: 100%; height: 1rem; }
  .alert {
    display:none; margin: 1rem 0; padding: .75rem 1rem;
    background: #ffebee; color: var(--warn); border: 1px solid var(--warn); border-radius: 8px;
    font-weight: 600;
    animation: pulse 1.2s infinite;
  }
  .alert.on { display:block; }
  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(183,28,28,.4); }
    70% { box-shadow: 0 0 0 12px rgba(183,28,28,0); }
    100% { box-shadow: 0 0 0 0 rgba(183,28,28,0); }
  }
</style>
<body>
  <h1>Mic sound detector to API</h1>

  <fieldset>
    <legend>Settings</legend>
    <label>API URL</label>
    <input id="apiUrl" type="text" placeholder="https://example.com/endpoint">
    <label>API bearer token, optional</label>
    <input id="apiToken" type="text" placeholder="abc123">
    <div class="row">
      <div>
        <label>RMS threshold</label>
        <input id="threshold" type="number" step="0.005" min="0.005" value="0.02">
      </div>
      <div>
        <label>Cooldown seconds</label>
        <input id="cooldown" type="number" min="0" value="30">
      </div>
      <div>
        <label>Hold seconds for alert</label>
        <input id="holdSecs" type="number" min="0.2" step="0.1" value="2">
      </div>
    </div>
  </fieldset>

  <div class="row">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="wakeBtn" title="Prevents the screen from sleeping">Screen wake lock</button>
  </div>

  <div id="alert" class="alert">Threshold held for over <span id="holdTarget">2</span> seconds</div>

  <fieldset>
    <legend>Live</legend>
    <label>Current RMS</label>
    <meter id="meter" min="0" max="0.2" value="0"></meter>

    <label style="margin-top:.75rem;">Hold progress</label>
    <meter id="holdMeter" min="0" max="2" value="0"></meter>

    <div class="status" id="status">Idle</div>
    <div class="status" id="lastSent">Last sent: never</div>
    <div class="status" id="holdInfo">Held above threshold: 0.00s</div>
  </fieldset>

<script>
let ac, mic, analyser, rafId, wakeLock;
let lastSent = 0;
let lastTime = 0;
let holdMs = 0;
let alertActive = false;

const meter = document.getElementById('meter');
const holdMeter = document.getElementById('holdMeter');
const statusEl = document.getElementById('status');
const lastSentEl = document.getElementById('lastSent');
const holdInfoEl = document.getElementById('holdInfo');
const alertEl = document.getElementById('alert');
const holdTargetEl = document.getElementById('holdTarget');

const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const wakeBtn = document.getElementById('wakeBtn');

async function start() {
  try {
    if (!location.protocol.startsWith('https') && location.hostname !== 'localhost') {
      alert('Mic access in browsers generally requires HTTPS. Serve this file over HTTPS.');
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });
    ac = new (window.AudioContext || window.webkitAudioContext)();
    mic = ac.createMediaStreamSource(stream);
    analyser = ac.createAnalyser();
    analyser.fftSize = 2048;
    mic.connect(analyser);

    holdMs = 0;
    alertActive = false;
    lastTime = performance.now();

    loop();
    startBtn.disabled = true;
    stopBtn.disabled = false;
    setStatus('Listening');
  } catch (e) {
    console.error(e);
    setStatus('Mic permission denied or unavailable');
  }
}

function stop() {
  cancelAnimationFrame(rafId);
  if (ac) ac.close();
  ac = mic = analyser = null;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  setStatus('Stopped');
  setAlert(false);
}

function setStatus(t) { statusEl.textContent = t; }
function setAlert(on) {
  alertActive = on;
  alertEl.classList.toggle('on', on);
}

function rmsFromTimeDomain(buf) {
  let sum = 0;
  for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
  return Math.sqrt(sum / buf.length);
}

async function notify(rms) {
  const url = document.getElementById('apiUrl').value.trim();
  if (!url) return;
  const token = document.getElementById('apiToken').value.trim();
  try {
    const res = await fetch(url, {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
        ...(token ? { 'authorization': `Bearer ${token}` } : {})
      },
      body: JSON.stringify({ event: 'sound_detected', rms: rms, ts: Math.floor(Date.now()/1000) })
    });
    lastSent = Date.now();
    lastSentEl.textContent = `Last sent: ${new Date(lastSent).toLocaleString()}. Status ${res.status}`;
  } catch (err) {
    console.error(err);
    lastSentEl.textContent = `Send failed at ${new Date().toLocaleString()}`;
  }
}

function loop() {
  const thresh = parseFloat(document.getElementById('threshold').value || '0.02');
  const cooldownMs = Math.max(0, parseInt(document.getElementById('cooldown').value || '30', 10) * 1000);
  const holdSecs = Math.max(0.2, parseFloat(document.getElementById('holdSecs').value || '2'));
  holdMeter.max = holdSecs;
  holdTargetEl.textContent = String(holdSecs);

  const now = performance.now();
  const dt = now - lastTime;
  lastTime = now;

  const buf = new Float32Array(analyser.fftSize);
  analyser.getFloatTimeDomainData(buf);
  const rms = rmsFromTimeDomain(buf);
  meter.value = Math.min(0.2, rms);

  const over = rms >= thresh;

  if (over) {
    holdMs += dt;
    if (!alertActive && holdMs >= holdSecs * 1000) {
      setAlert(true);
    }
  } else {
    holdMs = 0;
    if (alertActive) setAlert(false);
  }

  holdMeter.value = holdMs / 1000;
  holdInfoEl.textContent = `Held above threshold: ${(holdMs/1000).toFixed(2)}s`;

  const t = rms.toFixed(4);
  if (over && Date.now() - lastSent >= cooldownMs) {
    setStatus(`Sound detected, rms=${t}. Sending...`);
    notify(rms);
  } else {
    setStatus(`Listening, rms=${t}`);
  }

  rafId = requestAnimationFrame(loop);
}

// Screen wake lock to reduce throttling
async function toggleWake() {
  if ('wakeLock' in navigator) {
    try {
      if (!wakeLock) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeBtn.textContent = 'Release wake lock';
        wakeLock.addEventListener('release', () => wakeBtn.textContent = 'Screen wake lock');
      } else {
        await wakeLock.release();
        wakeLock = null;
        wakeBtn.textContent = 'Screen wake lock';
      }
    } catch (e) {
      alert('Wake lock not available');
    }
  } else {
    alert('Wake lock API not supported on this browser');
  }
}

startBtn.addEventListener('click', start);
stopBtn.addEventListener('click', stop);
wakeBtn.addEventListener('click', toggleWake);
</script>
</body>
</html>
